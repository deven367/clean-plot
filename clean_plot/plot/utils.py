# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/05_plot.utils.ipynb (unless otherwise specified).

__all__ = ['Plot']

# Cell
from fastcore.basics import store_attr
from fastcore.xtras import globtastic
from fastcore.meta import delegates
from fastcore.basics import patch_to, patch
from pathlib import Path
import os
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from ..pickle import label
from ..functions import normalize
import seaborn as sns
import matplotlib.pyplot as plt

# Cell
sns.set_style(style='white')

# Cell
#|hide
import inspect

# Cell
class Plot:
    def __init__(self, path):
        self.path = Path(path)
        self.norm = {}
        self.book_name = self.path.stem.replace('_', ' ')

    @delegates(globtastic)
    def view_all_files(self, **kwargs):
        return globtastic(self.path, **kwargs)

    def create_ssms(self):
        new_path = self.path/'full_plots'
        new_path.mkdir(exist_ok=True)

        for method, norm_ssm in self.norm.items():
            title = f'{self.book_name} {method}'
            sns.heatmap(norm_ssm, cmap='hot',
                        vmin=0, vmax=1, square=True,
                        xticklabels=False)
            length = norm_ssm.shape[0]
            ticks = np.linspace(1, length, 5, dtype=int)
            plt.yticks(ticks, ticks, rotation = 0)
            plt.ylabel('sentence number')
            plt.savefig(new_path/f'{title}.png', dpi = 300, bbox_inches='tight')
            print(f'Done plotting {title}.png')
            plt.clf()
            del norm_ssm


    def get_standardized(self):
        pass

    def get_corr_plots(self):
        pass

    def get_sectional_ssms(self):
        pass

    def __repr__(self):
        dir_path = os.path.dirname(os.path.realpath(self.path))
        return f'This object contains the path to `{dir_path}`'

# Cell
@patch
def get_normalized(self:Plot):
    "Returns the normalized ssms"
    files = self.view_all_files(file_glob='*.npy')
    for f in files:
        f = Path(f)
        fname = f.stem.split('_cleaned_')
        book, method = fname[0], label(fname[1])

        title = f'{book.title()} {method}'

        em = np.load(f)

        if fname[1] == 'lexical_wt_ssm':
            sim = em
            print(em.shape)
            n = normalize(sim)
            # modifies the input array inplace
            np.fill_diagonal(n, 1)
        else:
            sim = cosine_similarity(em, em)
            n = normalize(sim)

        self.norm[method] = n
        del em, sim, n
    return self.norm